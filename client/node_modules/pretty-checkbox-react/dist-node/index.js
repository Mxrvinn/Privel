'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var classNames = _interopDefault(require('classnames'));
var mergeRefs = _interopDefault(require('react-merge-refs'));
var nonSecure = require('nanoid/non-secure');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const INDETERMINATE_STATE = 'indeterminate';

const dispatch = value => state => {
  if (Array.isArray(state)) {
    const index = state.indexOf(value);

    if (index === -1) {
      state.push(value);
    } else {
      state.splice(index, 1);
    }

    return [...state];
  } else if (value !== '') {
    return [value];
  }

  return !state;
};

const useCheckboxState = ({
  state: initialState = false,
  onChange
} = {}) => {
  const [state, setState] = React.useState(() => {
    if (typeof initialState === 'string' && initialState !== INDETERMINATE_STATE) {
      return [initialState];
    }

    return initialState;
  });
  return {
    state,
    setState,
    onChange: React.useCallback(e => {
      const {
        value
      } = e.currentTarget;
      setState(dispatch(value));

      if (typeof onChange === 'function') {
        onChange(e);
      }
    }, [onChange])
  };
};

const lockedStyles = {
  pointerEvents: 'none'
};
/**
 * A simplier way to prevent checking when PCR is in locked mode.
 * This is way simplier than controlling the checkbox using
 * event handlers. Supports IE 11+
 */

const useLocked = ({
  locked,
  style
}) => {
  if (locked) {
    return _objectSpread2(_objectSpread2({}, lockedStyles), style);
  }

  return style;
};

const useIcon = icon => {
  return React.useMemo(() => {
    if (icon) {
      let type = 'icon';

      if (icon.type === 'img') {
        type = 'image';
      } else if (icon.type === 'svg') {
        type = 'svg';
      } // icons that contain `type` substring
      // won't fail with a word boundary search


      const re = new RegExp(`\\b${type}\\b`);
      return {
        iconType: icon.props['data-type'] || type,
        icon: icon.props.className && !re.test(icon.props.className) ? React.cloneElement(icon, _objectSpread2(_objectSpread2({}, icon.props), {}, {
          className: classNames(icon.props.className, type)
        })) : icon
      };
    }

    return {};
  }, [icon]);
};

const isDefault = (animation, type) => {
  if (type) {
    return false;
  }

  return !animation || animation === 'smooth' || animation === 'pulse';
};
/**
 * Responsible for returning an object used by classnames
 * to properly add the className values to the .pretty element.
 */


const useClassNames = (props, isSwitch) => {
  const {
    animation,
    bigger,
    locked,
    plain,
    shape,
    variant,
    iconType,
    hasFocus
  } = props;
  return {
    'p-default': !isSwitch && isDefault(animation, iconType),
    'p-bigger': bigger,
    'p-locked': locked,
    'p-plain': plain,
    'p-has-focus': hasFocus,
    [`p-${animation}`]: animation,
    [`p-${shape}`]: shape,
    [`p-${variant}`]: variant,
    [`p-${iconType}`]: iconType
  };
};

const isBoolean = e => typeof e === 'boolean';

const isNullish = e => e === null || e === undefined;

const isIndeterminate = e => e === 'indeterminate';
/**
 * A generic way to setup controlled components by
 * removing  state hook return results, setting `checked`,
 * and `value` props too.
 */


const useControlled = props => {
  // remove state and state dispatch from the props
  // eslint-disable-next-line prefer-const
  let {
    checked,
    state,
    setState,
    value,
    defaultValue
  } = props,
      rest = _objectWithoutProperties(props, ["checked", "state", "setState", "value", "defaultValue"]); // if a dispatcher is used, then we're good to run the rest
  // of the logic


  if (setState) {
    // if state is defined and checked is NOT defined
    // then use state to set the value of checked.
    if ((isBoolean(state) || isIndeterminate(state)) && !isBoolean(checked) && isNullish(checked)) {
      checked = !!state;
    } else if (Array.isArray(state)) {
      // otherwise set checked true if the value is contained
      // within the state.
      checked = state.includes(value);
    } else if (isNullish(checked)) {
      // The type is not a boolean and is probably a string.
      // If you're attempting to use this hook in a different
      // way, then you should considering controlling the component
      // yourself. Object.is used here just in case ;)
      checked = Object.is(state, value);
    } // preset the value prop in controlled mode to an empty
    // string to prevent 'on' values. Use the defaultValue
    // if provided


    if (isNullish(value)) {
      value = defaultValue || '';
    }
  }

  return _objectSpread2({
    checked,
    value,
    state
  }, rest);
};

const PREFIX = 'pcr_';
const useUUID = () => React.useRef(PREFIX + nonSecure.nanoid(8)).current;

/**
 * Filters out the noise of prop mayhem with PCR. This separates
 * all props from the native HTML props that will eventually get passed
 * to the input element. Generated PCR UUIDs are created here, unless
 * user has specified one of their own.
 */

const useCommonProps = props => {
  const defaultId = useUUID();

  const {
    locked,
    color,
    variant,
    animation,
    children,
    style,
    id = defaultId,
    className,
    bigger,
    hasFocus
  } = props,
        rest = _objectWithoutProperties(props, ["locked", "color", "variant", "animation", "children", "style", "id", "className", "bigger", "hasFocus"]);

  return {
    locked,
    color,
    variant,
    animation,
    children,
    id,
    className,
    bigger,
    style,
    hasFocus,
    htmlProps: rest
  };
};

/**
 * Responsible for extracting common props for radio and checkbox
 * controls.
 */

const useCheckboxRadioProps = props => {
  const {
    shape,
    plain,
    icon,
    indeterminate,
    hasFocus
  } = props,
        rest = _objectWithoutProperties(props, ["shape", "plain", "icon", "indeterminate", "hasFocus"]);

  return _objectSpread2({
    shape,
    plain,
    icon,
    indeterminate
  }, useCommonProps(rest));
};

/**
 * A tiny component to abstract away pretty-checkbox "state" div.
 * Shared by all components.
 */

const State = (_ref) => {
  let {
    color,
    icon,
    id,
    children
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["color", "icon", "id", "children"]);

  return React.createElement("div", Object.assign({
    className: classNames('state', color && `p-${color}`)
  }, rest), icon, React.createElement("label", {
    htmlFor: id
  }, children));
};
State.displayName = 'State';

const useIndeterminate = ({
  checked,
  state,
  indeterminate: indeterminateFromProps
}) => {
  const [indeterminate, setStatus] = React.useState(false);
  const ref = React.useRef(null);
  React.useEffect(() => {
    if (state !== undefined && ref.current) {
      setStatus(state === 'indeterminate');
    }
  }, [state]); // if a prop is passed mark the indeterminate state
  // we should check to ensure state isn't set to indeterminate
  // since we don't want ot clobber the state value if
  // it is defined.

  React.useEffect(() => {
    if (state !== 'indeterminate' && ref.current && typeof indeterminateFromProps !== 'undefined') {
      ref.current.checked = indeterminateFromProps; // fix needs to come from pretty-checkbox
      // ref.current.indeterminate = indeterminateFromProps;

      setStatus(indeterminateFromProps);
    }
  }, [indeterminateFromProps, state]);
  return {
    ref,
    'aria-checked': indeterminate ? 'mixed' : checked
  };
};

const Checkbox = React.forwardRef((props, ref) => {
  const _useControlled = useControlled(props),
        {
    checked,
    value,
    state
  } = _useControlled,
        rest = _objectWithoutProperties(_useControlled, ["checked", "value", "state"]);

  const {
    children,
    locked,
    color,
    id,
    className,
    style,
    indeterminate,
    icon: propsIcon,
    htmlProps
  } = useCheckboxRadioProps(rest);

  const _useIndeterminate = useIndeterminate({
    state,
    checked,
    indeterminate
  }),
        {
    ref: intRef
  } = _useIndeterminate,
        aria = _objectWithoutProperties(_useIndeterminate, ["ref"]);

  const styles = useLocked({
    locked,
    style
  });
  const {
    icon,
    iconType
  } = useIcon(propsIcon);
  return React.createElement("div", {
    style: styles,
    className: classNames('pretty', useClassNames(_objectSpread2(_objectSpread2({}, props), {}, {
      iconType
    })), className)
  }, React.createElement("input", Object.assign({
    ref: mergeRefs([ref, intRef]),
    value: value,
    type: "checkbox",
    id: id,
    checked: checked
  }, aria, htmlProps)), React.createElement(State, {
    id: id,
    icon: icon,
    color: color
  }, children));
});
Checkbox.displayName = 'Checkbox';

const useRadioState = ({
  state: initialState = false,
  onChange
} = {}) => {
  const [state, setState] = React.useState(initialState);
  return {
    state,
    setState,
    onChange: React.useCallback(e => {
      const {
        value
      } = e.currentTarget;
      setState(current => {
        if (value !== '') {
          return value;
        }

        return !current;
      });

      if (typeof onChange === 'function') {
        onChange(e);
      }
    }, [onChange])
  };
};

const Radio = React.forwardRef((props, ref) => {
  const _useControlled = useControlled(props),
        {
    checked,
    value,
    state
  } = _useControlled,
        rest = _objectWithoutProperties(_useControlled, ["checked", "value", "state"]);

  const {
    shape = 'round',
    children,
    locked,
    color,
    id,
    className,
    style,
    icon: propsIcon,
    htmlProps
  } = useCheckboxRadioProps(rest);
  const styles = useLocked({
    locked,
    style
  });
  const {
    icon,
    iconType
  } = useIcon(propsIcon);
  return React.createElement("div", {
    style: styles,
    className: classNames('pretty', useClassNames(_objectSpread2(_objectSpread2({}, props), {}, {
      shape,
      iconType
    })), className)
  }, React.createElement("input", Object.assign({
    ref: ref,
    value: value,
    type: "radio",
    id: id,
    checked: checked
  }, htmlProps)), React.createElement(State, {
    id: id,
    icon: icon,
    color: color
  }, children));
});
Radio.displayName = 'Radio';

const handler = e => {
  e.currentTarget.setAttribute('aria-checked', e.currentTarget.checked + '');
};
/**
 * A small hook to help manage correct aria-checked state when switch
 * is used as an uncontrolled component. We need this to run
 * for a11y purposes. FOr the `switch` role, `aria-checked` is required.
 */


const useAriaChecked = ({
  setState,
  checked
}) => {
  const ref = React.useRef(null);
  React.useEffect(() => {
    const elem = ref.current;
    let bound = false;

    if (!setState && !checked && elem) {
      elem.setAttribute('aria-checked', elem.checked + '');
      elem.addEventListener('change', handler);
      bound = true;
    }

    return () => {
      if (bound && elem) {
        elem.removeEventListener('change', handler);
      }
    };
  }, [setState, checked]);
  return ref;
};

const Switch = React.forwardRef((props, ref) => {
  const _useControlled = useControlled(props),
        {
    checked,
    value,
    state
  } = _useControlled,
        rest = _objectWithoutProperties(_useControlled, ["checked", "value", "state"]);

  const {
    children,
    locked,
    color,
    id,
    className,
    style,
    htmlProps
  } = useCommonProps(rest);
  const styles = useLocked({
    locked,
    style
  });
  const htmlRef = useAriaChecked({
    setState: props.setState,
    checked
  });
  return React.createElement("div", {
    style: styles,
    className: classNames('pretty', 'p-switch', useClassNames(props, true), className)
  }, React.createElement("input", Object.assign({
    ref: mergeRefs([ref, htmlRef]),
    type: "checkbox",
    role: "switch",
    value: value,
    id: id,
    "aria-checked": checked,
    checked: checked
  }, htmlProps)), React.createElement(State, {
    id: id,
    color: color
  }, children));
});
Switch.displayName = 'Switch';

exports.Checkbox = Checkbox;
exports.Radio = Radio;
exports.Switch = Switch;
exports.useCheckboxState = useCheckboxState;
exports.useRadioState = useRadioState;
//# sourceMappingURL=index.js.map
