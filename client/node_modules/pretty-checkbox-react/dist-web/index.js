import { useState, useCallback, useMemo, cloneElement, useRef, createElement, useEffect, forwardRef } from 'react';
import classNames from 'classnames';
import mergeRefs from 'react-merge-refs';
import { nanoid } from 'nanoid/non-secure';

const INDETERMINATE_STATE = 'indeterminate';
const dispatch = (value) => (state) => {
    if (Array.isArray(state)) {
        const index = state.indexOf(value);
        if (index === -1) {
            state.push(value);
        }
        else {
            state.splice(index, 1);
        }
        return [...state];
    }
    else if (value !== '') {
        return [value];
    }
    return !state;
};
const useCheckboxState = ({ state: initialState = false, onChange, } = {}) => {
    const [state, setState] = useState(() => {
        if (typeof initialState === 'string' && initialState !== INDETERMINATE_STATE) {
            return [initialState];
        }
        return initialState;
    });
    return {
        state,
        setState,
        onChange: useCallback((e) => {
            const { value } = e.currentTarget;
            setState(dispatch(value));
            if (typeof onChange === 'function') {
                onChange(e);
            }
        }, [onChange]),
    };
};

const lockedStyles = { pointerEvents: 'none' };
/**
 * A simplier way to prevent checking when PCR is in locked mode.
 * This is way simplier than controlling the checkbox using
 * event handlers. Supports IE 11+
 */
const useLocked = ({ locked, style }) => {
    if (locked) {
        return {
            ...lockedStyles,
            ...style,
        };
    }
    return style;
};

const useIcon = (icon) => {
    return useMemo(() => {
        if (icon) {
            let type = 'icon';
            if (icon.type === 'img') {
                type = 'image';
            }
            else if (icon.type === 'svg') {
                type = 'svg';
            }
            // icons that contain `type` substring
            // won't fail with a word boundary search
            const re = new RegExp(`\\b${type}\\b`);
            return {
                iconType: icon.props['data-type'] || type,
                icon: icon.props.className && !re.test(icon.props.className)
                    ? cloneElement(icon, {
                        ...icon.props,
                        className: classNames(icon.props.className, type),
                    })
                    : icon,
            };
        }
        return {};
    }, [icon]);
};

const isDefault = (animation, type) => {
    if (type) {
        return false;
    }
    return !animation || animation === 'smooth' || animation === 'pulse';
};
/**
 * Responsible for returning an object used by classnames
 * to properly add the className values to the .pretty element.
 */
const useClassNames = (props, isSwitch) => {
    const { animation, bigger, locked, plain, shape, variant, iconType, hasFocus } = props;
    return {
        'p-default': !isSwitch && isDefault(animation, iconType),
        'p-bigger': bigger,
        'p-locked': locked,
        'p-plain': plain,
        'p-has-focus': hasFocus,
        [`p-${animation}`]: animation,
        [`p-${shape}`]: shape,
        [`p-${variant}`]: variant,
        [`p-${iconType}`]: iconType,
    };
};

const isBoolean = (e) => typeof e === 'boolean';
const isNullish = (e) => e === null || e === undefined;
const isIndeterminate = (e) => e === 'indeterminate';
/**
 * A generic way to setup controlled components by
 * removing  state hook return results, setting `checked`,
 * and `value` props too.
 */
const useControlled = (props) => {
    // remove state and state dispatch from the props
    // eslint-disable-next-line prefer-const
    let { checked, state, setState, value, defaultValue, ...rest } = props;
    // if a dispatcher is used, then we're good to run the rest
    // of the logic
    if (setState) {
        // if state is defined and checked is NOT defined
        // then use state to set the value of checked.
        if ((isBoolean(state) || isIndeterminate(state)) &&
            !isBoolean(checked) &&
            isNullish(checked)) {
            checked = !!state;
        }
        else if (Array.isArray(state)) {
            // otherwise set checked true if the value is contained
            // within the state.
            checked = state.includes(value);
        }
        else if (isNullish(checked)) {
            // The type is not a boolean and is probably a string.
            // If you're attempting to use this hook in a different
            // way, then you should considering controlling the component
            // yourself. Object.is used here just in case ;)
            checked = Object.is(state, value);
        }
        // preset the value prop in controlled mode to an empty
        // string to prevent 'on' values. Use the defaultValue
        // if provided
        if (isNullish(value)) {
            value = defaultValue || '';
        }
    }
    return { checked, value, state, ...rest };
};

const PREFIX = 'pcr_';
const useUUID = () => useRef(PREFIX + nanoid(8)).current;

/**
 * Filters out the noise of prop mayhem with PCR. This separates
 * all props from the native HTML props that will eventually get passed
 * to the input element. Generated PCR UUIDs are created here, unless
 * user has specified one of their own.
 */
const useCommonProps = (props) => {
    const defaultId = useUUID();
    const { locked, color, variant, animation, children, style, id = defaultId, className, bigger, hasFocus, ...rest } = props;
    return {
        locked,
        color,
        variant,
        animation,
        children,
        id,
        className,
        bigger,
        style,
        hasFocus,
        htmlProps: rest,
    };
};

/**
 * Responsible for extracting common props for radio and checkbox
 * controls.
 */
const useCheckboxRadioProps = (props) => {
    const { shape, plain, icon, indeterminate, hasFocus, ...rest } = props;
    return { shape, plain, icon, indeterminate, ...useCommonProps(rest) };
};

/**
 * A tiny component to abstract away pretty-checkbox "state" div.
 * Shared by all components.
 */
const State = ({ color, icon, id, children, ...rest }) => {
    return (createElement("div", Object.assign({ className: classNames('state', color && `p-${color}`) }, rest),
        icon,
        createElement("label", { htmlFor: id }, children)));
};
State.displayName = 'State';

const useIndeterminate = ({ checked, state, indeterminate: indeterminateFromProps, }) => {
    const [indeterminate, setStatus] = useState(false);
    const ref = useRef(null);
    useEffect(() => {
        if (state !== undefined && ref.current) {
            setStatus(state === 'indeterminate');
        }
    }, [state]);
    // if a prop is passed mark the indeterminate state
    // we should check to ensure state isn't set to indeterminate
    // since we don't want ot clobber the state value if
    // it is defined.
    useEffect(() => {
        if (state !== 'indeterminate' &&
            ref.current &&
            typeof indeterminateFromProps !== 'undefined') {
            ref.current.checked = indeterminateFromProps;
            // fix needs to come from pretty-checkbox
            // ref.current.indeterminate = indeterminateFromProps;
            setStatus(indeterminateFromProps);
        }
    }, [indeterminateFromProps, state]);
    return {
        ref,
        'aria-checked': indeterminate ? 'mixed' : checked,
    };
};

const Checkbox = forwardRef((props, ref) => {
    const { checked, value, state, ...rest } = useControlled(props);
    const { children, locked, color, id, className, style, indeterminate, icon: propsIcon, htmlProps, } = useCheckboxRadioProps(rest);
    const { ref: intRef, ...aria } = useIndeterminate({ state, checked, indeterminate });
    const styles = useLocked({ locked, style });
    const { icon, iconType } = useIcon(propsIcon);
    return (createElement("div", { style: styles, className: classNames('pretty', useClassNames({
            ...props,
            iconType,
        }), className) },
        createElement("input", Object.assign({ ref: mergeRefs([ref, intRef]), value: value, type: "checkbox", id: id, checked: checked }, aria, htmlProps)),
        createElement(State, { id: id, icon: icon, color: color }, children)));
});
Checkbox.displayName = 'Checkbox';

const useRadioState = ({ state: initialState = false, onChange } = {}) => {
    const [state, setState] = useState(initialState);
    return {
        state,
        setState,
        onChange: useCallback((e) => {
            const { value } = e.currentTarget;
            setState(current => {
                if (value !== '') {
                    return value;
                }
                return !current;
            });
            if (typeof onChange === 'function') {
                onChange(e);
            }
        }, [onChange]),
    };
};

const Radio = forwardRef((props, ref) => {
    const { checked, value, state, ...rest } = useControlled(props);
    const { shape = 'round', children, locked, color, id, className, style, icon: propsIcon, htmlProps, } = useCheckboxRadioProps(rest);
    const styles = useLocked({ locked, style });
    const { icon, iconType } = useIcon(propsIcon);
    return (createElement("div", { style: styles, className: classNames('pretty', useClassNames({
            ...props,
            shape,
            iconType,
        }), className) },
        createElement("input", Object.assign({ ref: ref, value: value, type: "radio", id: id, checked: checked }, htmlProps)),
        createElement(State, { id: id, icon: icon, color: color }, children)));
});
Radio.displayName = 'Radio';

const handler = (e) => {
    e.currentTarget.setAttribute('aria-checked', e.currentTarget.checked + '');
};
/**
 * A small hook to help manage correct aria-checked state when switch
 * is used as an uncontrolled component. We need this to run
 * for a11y purposes. FOr the `switch` role, `aria-checked` is required.
 */
const useAriaChecked = ({ setState, checked }) => {
    const ref = useRef(null);
    useEffect(() => {
        const elem = ref.current;
        let bound = false;
        if (!setState && !checked && elem) {
            elem.setAttribute('aria-checked', elem.checked + '');
            elem.addEventListener('change', handler);
            bound = true;
        }
        return () => {
            if (bound && elem) {
                elem.removeEventListener('change', handler);
            }
        };
    }, [setState, checked]);
    return ref;
};

const Switch = forwardRef((props, ref) => {
    const { checked, value, state, ...rest } = useControlled(props);
    const { children, locked, color, id, className, style, htmlProps } = useCommonProps(rest);
    const styles = useLocked({ locked, style });
    const htmlRef = useAriaChecked({ setState: props.setState, checked });
    return (createElement("div", { style: styles, className: classNames('pretty', 'p-switch', useClassNames(props, true), className) },
        createElement("input", Object.assign({ ref: mergeRefs([ref, htmlRef]), type: "checkbox", role: "switch", value: value, id: id, "aria-checked": checked, checked: checked }, htmlProps)),
        createElement(State, { id: id, color: color }, children)));
});
Switch.displayName = 'Switch';

export { Checkbox, Radio, Switch, useCheckboxState, useRadioState };
//# sourceMappingURL=index.js.map
